

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>EMMap &mdash; TEMpy 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="TEMpy 1.0.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/test6.png" border="0" alt="TEMPy"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>

          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for EMMap</h1><div class="highlight"><pre>
<span class="c">#===============================================================================</span>
<span class="c">#     This file is part of TEMPy.</span>
<span class="c">#     </span>
<span class="c">#     TEMPy is a free software designed to help the user in the manipulation </span>
<span class="c">#     and analyses of macromolecular assemblies using 3D electron microscopy maps. </span>
<span class="c">#     </span>
<span class="c">#     Copyright (C) 2013 Irene Farabella, Daven Vasishtan, Arun Prasad Pandurangan, </span>
<span class="c">#                        Agnel-Praveen Joseph, Harpal Sahota and Maya Topf.</span>
<span class="c"># </span>
<span class="c"># </span>
<span class="c">#     TEMPy is free software: you can redistribute it and/or modify</span>
<span class="c">#     it under the terms of the GNU General Public License as published by</span>
<span class="c">#     the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#     (at your option) any later version.</span>
<span class="c"># </span>
<span class="c">#     TEMPy is distributed in the hope that it will be useful,</span>
<span class="c">#     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#     GNU General Public License for more details.</span>
<span class="c"># </span>
<span class="c">#     You should have received a copy of the GNU General Public License</span>
<span class="c">#     along with TEMPy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#     </span>
<span class="c">#     Please cite your use of TEMPy in published work:</span>
<span class="c"># </span>
<span class="c">#     I. Farabella ,D.Vasishtan, A. P. Pandurangan, H. Sahota and M. Topf .</span>
<span class="c">#     TEMPy: Tool for Scoring and Assessment into 3D EM Maps using Python </span>
<span class="c">#     XXXXX</span>
<span class="c">#===============================================================================</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span>  <span class="n">array</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">ma</span><span class="p">,</span> <span class="nb">sum</span> <span class="k">as</span> <span class="n">numsum</span><span class="p">,</span><span class="n">median</span>

<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="kn">import</span>  <span class="n">shift</span><span class="p">,</span> <span class="n">affine_transform</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">laplace</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">struct</span> <span class="kn">as</span> <span class="nn">binary</span>
<span class="kn">import</span> <span class="nn">TEMPy.Vector</span>  <span class="kn">as</span> <span class="nn">Vector</span>
<span class="kn">from</span> <span class="nn">TEMPy.ProtRep_Biopy</span> <span class="kn">import</span> <span class="n">BioPy_Structure</span><span class="p">,</span><span class="n">BioPyAtom</span>


<div class="viewcode-block" id="Map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map">[docs]</a><span class="k">class</span> <span class="nc">Map</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    </span>
<span class="sd">    A class representing all information from a density map file. </span>
<span class="sd">    NOTE: Currently it can only read the CCP4/MRC  format.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullMap</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">apix</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Read a map and its parameters in to Map class instance.</span>
<span class="sd">        </span>
<span class="sd">        *filename*</span>
<span class="sd">            name of map file.</span>
<span class="sd">        *origin*    </span>
<span class="sd">            origin co-ordinates of the map (x_origin, y_origin, z_origin).</span>
<span class="sd">        *apix*</span>
<span class="sd">            grid spacing of map.</span>
<span class="sd">        *filename*</span>
<span class="sd">            filename of the Map instance</span>
<span class="sd">            </span>
<span class="sd">            NOTE: The *filename* &#39;build++copy&#39; is reserved for copying of other Map class instances.&quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apix</span> <span class="o">=</span> <span class="n">apix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">fullMap</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">box_size</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">())</span>
        <span class="n">box_size</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">string1</span> <span class="o">=</span> <span class="s">&#39;Obtained from &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">string2</span> <span class="o">=</span> <span class="s">&#39;Origin: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">string3</span> <span class="o">=</span> <span class="s">&#39;Box size (x,y,z): &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">box_size</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">string4</span> <span class="o">=</span> <span class="s">&#39;Grid spacing: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">string5</span> <span class="o">=</span> <span class="s">&#39;Min, max, mean, std: </span><span class="si">%.3f</span><span class="s">, </span><span class="si">%.3f</span><span class="s">, </span><span class="si">%.3f</span><span class="s">, </span><span class="si">%.3f</span><span class="s"> </span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">string1</span> <span class="o">+</span> <span class="n">string2</span> <span class="o">+</span> <span class="n">string3</span> <span class="o">+</span> <span class="n">string4</span> <span class="o">+</span><span class="n">string5</span>

<div class="viewcode-block" id="Map.x_origin"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.x_origin">[docs]</a>    <span class="k">def</span> <span class="nf">x_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Return:</span>
<span class="sd">             x-coordinate of the origin.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Map.y_origin"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.y_origin">[docs]</a>    <span class="k">def</span> <span class="nf">y_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            y-coordinate of the origin.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Map.z_origin"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.z_origin">[docs]</a>    <span class="k">def</span> <span class="nf">z_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            z-coordinate of the origin.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="Map.copy"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            copy of the Map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[:])</span>
        <span class="k">return</span> <span class="n">copy</span>
</div>
<div class="viewcode-block" id="Map.getMap"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.getMap">[docs]</a>    <span class="k">def</span> <span class="nf">getMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            array containing the map density data.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span>
</div>
<div class="viewcode-block" id="Map.box_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.box_size">[docs]</a>    <span class="k">def</span> <span class="nf">box_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            size of the map array, in ZYX format.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">shape</span>
</div>
<div class="viewcode-block" id="Map.x_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.x_size">[docs]</a>    <span class="k">def</span> <span class="nf">x_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            x size of the map array in x direction.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="Map.y_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.y_size">[docs]</a>    <span class="k">def</span> <span class="nf">y_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            y size of the map array in y direction.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="Map.z_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.z_size">[docs]</a>    <span class="k">def</span> <span class="nf">z_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            z size of the map array in z direction.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
<div class="viewcode-block" id="Map.map_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.map_size">[docs]</a>    <span class="k">def</span> <span class="nf">map_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            size of the array fullMap.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">size</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Allows direct indexing of the map array from the Map instance.</span>
<span class="sd">        ie. map[2][2][1] instead of map.fullMap[2][2][1]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c"># -- Map modification methods. All of them return a new Map instance. -- #</span>

<div class="viewcode-block" id="Map.scale_map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.scale_map">[docs]</a>    <span class="k">def</span> <span class="nf">scale_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scaling Map by scaling factor</span>

<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">scaling</span>
        <span class="n">c_sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_centre</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sc</span><span class="p">)</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">diag</span><span class="p">([</span><span class="n">sc</span><span class="p">,</span><span class="n">sc</span><span class="p">,</span><span class="n">sc</span><span class="p">]),</span> <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="n">c_sh</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">c_sh</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">c_sh</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
        <span class="c">#newMap.apix = newMap.apix/scaling</span>
        <span class="c">#newMap.origin -= array(newMap.origin)*(self.apix-newMap.apix)/2</span>
        <span class="c">#newMap.origin = list(newMap.origin)</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.resize_map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.resize_map">[docs]</a>    <span class="k">def</span> <span class="nf">resize_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Resize Map instance.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">           </span>
<span class="sd">           *new_size*</span>
<span class="sd">               3-tuple (x,y,z) giving the box size.</span>
<span class="sd">            *centre*</span>
<span class="sd">                default False</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance</span>
<span class="sd">               </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">new_size</span><span class="p">)</span>
        <span class="n">min_box</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">newMap</span><span class="o">.</span><span class="n">box_size</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">())]</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">min_box</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">newMap</span>
    
</div>
<div class="viewcode-block" id="Map.normalise"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.normalise">[docs]</a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return a new Map instance with normalised density values.</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.rotate_by_axis_angle"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.rotate_by_axis_angle">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_by_axis_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">CoM</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Rotate the map around its centre given an axis and angle. </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">            *angle*</span>
<span class="sd">                angle (in radians if rad == True, else in degrees) to rotate map.</span>
<span class="sd">            *x,y,z*</span>
<span class="sd">                axis to rotate about, ie. x,y,z =  0,0,1 rotates the Map round the xy-plane.</span>
<span class="sd">            *CoM*</span>
<span class="sd">                centre of mass around which map will be rotated.</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">               </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">m</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">axis_angle_to_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
        <span class="c"># Calculate translation needed to rotate around CoM</span>
        <span class="n">newCoM</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">-</span><span class="n">newCoM</span>
        <span class="c"># Apply transform</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.rotate_by_euler"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.rotate_by_euler">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_by_euler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">CoM</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Rotated map around pivot given by CoM using Euler angles. </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">            *x,y,z*</span>
<span class="sd">                Euler angles (in radians if rad == True, else in degrees) used to rotate map.</span>
<span class="sd">            *CoM*</span>
<span class="sd">                centre of mass around which map will be rotated.</span>
<span class="sd">            *x, y, z*</span>
<span class="sd">                translation in angstroms.</span>
<span class="sd">  </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">euler_to_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
        <span class="c"># Calculate translation needed to rotate around CoM</span>
        <span class="n">newCoM</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">-</span><span class="n">newCoM</span>
        <span class="c"># Apply transform</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>

<span class="c">#===============================================================================</span>
<span class="c">#     def randomise_position(self, max_trans, max_rot, CoM, v_grain=30, rad=False, verbose=False):</span>
<span class="c">#         ###ASK how and who wrote it. WHAT is i (guess structure to generate ensamble)</span>
<span class="c">#         </span>
<span class="c">#         &quot;&quot;&quot;</span>
<span class="c">#         </span>
<span class="c">#         Randomise the position of this Map Instance. </span>
<span class="c">#         </span>
<span class="c">#         FOR IRENE:</span>
<span class="c">#         </span>
<span class="c">#         CTRL private _map_randomise_position for Arun that now is updated in GA so I can delete it from here.</span>
<span class="c">#         ###ASK how and who wrote it. WHAT is i (guess structure to generate ensamble)</span>
<span class="c">#         returns a translated map and parameter. if it is not used elsewhere (e.g Assembly/GA) We can re-write it </span>
<span class="c">#         in a way that  it will return only randomized new map and maybe rotation values as option. </span>
<span class="c">#         </span>
<span class="c">#         Arguments:</span>
<span class="c">#             *max_trans*</span>
<span class="c">#                 translation in angstroms.</span>
<span class="c">#             *max_rot*</span>
<span class="c">#                 Euler angles (in radians if rad == True, else in degrees) used to rotate map.</span>
<span class="c">#             *CoM*</span>
<span class="c">#                 centre of mass around which map will be rotated.</span>
<span class="c">#             *v_grain*</span>
<span class="c">#                 number of point to sample. Default is 30.</span>
<span class="c">#  </span>
<span class="c">#         Return:</span>
<span class="c">#             new Map instance         </span>
<span class="c">#                </span>
<span class="c">#         &quot;&quot;&quot;</span>
<span class="c">#         t_v = random_vector(-v_grain, v_grain).unit()</span>
<span class="c">#         r_v = random_vector(-v_grain, v_grain).unit()</span>
<span class="c"># 	j = 1</span>
<span class="c">#         if max_trans &lt;= 0:</span>
<span class="c">#             t_dist = 0</span>
<span class="c">#         else:</span>
<span class="c">#             t_dist = randrange(1,max_trans)</span>
<span class="c"># </span>
<span class="c">#         if max_rot &lt;= 0:</span>
<span class="c">#             r_ang = 0</span>
<span class="c">#         else:</span>
<span class="c">#             r_ang = randrange(1,max_rot)</span>
<span class="c">#         t_v = t_v.times(t_dist)</span>
<span class="c">#         self.rotate_by_axis_angle(r_v.x, r_v.y, r_v.z, r_ang, CoM, rad=rad)</span>
<span class="c">#         if verbose:</span>
<span class="c">#             print r_v.x, r_v.y, r_v.z, r_ang, t_v.x, t_v.y, t_v.z</span>
<span class="c"># 	return self.translate(t_v.x, t_v.y, t_v.z),r_v.x,r_v.y,r_v.z,t_dist,r_ang</span>
<span class="c">#===============================================================================</span>
</div>
<div class="viewcode-block" id="Map.rotate_by_matrix"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.rotate_by_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_by_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">CoM</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Rotated the map around pivot given by CoM using a rotation matrix </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *mat*</span>
<span class="sd">                3x3 matrix used to rotate map (in radians if rad == True, else in degrees).</span>
<span class="sd">            *CoM*</span>
<span class="sd">                rotation pivot, usually the centre of mass around which map will be rotated.</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Calculate translation needed to rotate around CoM</span>
        <span class="n">newCoM</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">-</span><span class="n">newCoM</span>
        <span class="c"># Apply transform</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>
        
</div>
<div class="viewcode-block" id="Map.matrix_transform"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.matrix_transform">[docs]</a>    <span class="k">def</span> <span class="nf">matrix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Apply affine transform to the map.</span>
<span class="sd">                </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            </span>
<span class="sd">            *mat*</span>
<span class="sd">               affine 3x3 transformation matrix</span>
<span class="sd">            *x, y, z*</span>
<span class="sd">                translation in angstroms.</span>

<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># Transpose matrix</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
        <span class="c"># Convert offsets from angstrom to pixel values</span>
        <span class="n">off_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>
        <span class="n">off_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>
        <span class="n">off_z</span> <span class="o">=</span> <span class="n">z</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>
        <span class="c"># Calculate offsets due to rotation around (0,0,0) origin</span>
        <span class="n">x_o</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>
        <span class="n">y_o</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>
        <span class="n">z_o</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">z_origin</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span>

        <span class="n">off_x</span> <span class="o">+=</span> <span class="n">x_o</span><span class="o">-</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z_o</span>
        <span class="n">off_y</span> <span class="o">+=</span> <span class="n">y_o</span><span class="o">-</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z_o</span>
        <span class="n">off_z</span> <span class="o">+=</span> <span class="n">z_o</span><span class="o">-</span><span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y_o</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z_o</span>

        <span class="n">off_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">off_x</span><span class="p">)</span>
        <span class="n">off_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">off_y</span><span class="p">)</span>
        <span class="n">off_z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">off_z</span><span class="p">)</span>
        
        <span class="c"># Swap z and x axes, apply matrix, then swap back</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">off_x</span><span class="p">,</span> <span class="n">off_y</span><span class="p">,</span> <span class="n">off_z</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.change_origin"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.change_origin">[docs]</a>    <span class="k">def</span> <span class="nf">change_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">z_origin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Change the origin of the map to a new origin. </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            </span>
<span class="sd">        *x_origin, y_origin, z_origin*</span>
<span class="sd">            new co-ordinates of origin.</span>

<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">z_origin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.shift_origin"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.shift_origin">[docs]</a>    <span class="k">def</span> <span class="nf">shift_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">z_shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Shift the Map origin.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            </span>
<span class="sd">        *x_origin, y_origin, z_origin*</span>
<span class="sd">            new co-ordinates of origin.</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">y_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">z_shift</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>
</div>
<div class="viewcode-block" id="Map.translate"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Translate the map by changing origin      </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *x,y,z*</span>
<span class="sd">                 translation in angstroms</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">z</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">,</span><span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">])</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="c">#f_map = fftn(newMap.fullMap)</span>
        <span class="c">#newMap.fullMap = real(ifftn((fourier_shift(f_map, shift))))</span>
        <span class="k">return</span> <span class="n">newMap</span>
    </div>
<div class="viewcode-block" id="Map.origin_change_maps"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.origin_change_maps">[docs]</a>    <span class="k">def</span> <span class="nf">origin_change_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">MapRef</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return a new Map instance with origin changed accordingly to Reference Map </span>
<span class="sd">            </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *MapRef*</span>
<span class="sd">                Reference Map</span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">origin_shift</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">newMap</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">MapRef</span><span class="o">.</span><span class="n">origin</span><span class="p">)]</span>
        <span class="c">#m2 = m2.shift_origin(origin_shift[0],origin_shift[1],origin_shift[2])</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">origin_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">origin_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">origin_shift</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">MapRef</span><span class="o">.</span><span class="n">origin</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">newMap</span>
    
</div>
<div class="viewcode-block" id="Map.threshold_map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.threshold_map">[docs]</a>    <span class="k">def</span> <span class="nf">threshold_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minDens</span><span class="p">,</span> <span class="n">maxDens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Create a Map instance containing only density values between the specified min and max values. </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            </span>
<span class="sd">            *minDens*</span>
<span class="sd">                minimum density threshold</span>
<span class="sd">            *maxDens*</span>
<span class="sd">                maximum density threshold</span>
<span class="sd">  </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newMap1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap1</span> <span class="o">=</span> <span class="n">newMap1</span><span class="o">*</span><span class="p">(</span><span class="n">newMap1</span><span class="o">&lt;</span><span class="n">maxDens</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">newMap1</span><span class="o">&gt;</span><span class="n">minDens</span><span class="p">)</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">newMap1</span>
        <span class="k">return</span> <span class="n">newMap</span>
    
    
    <span class="c">#add by AP</span>
    <span class="c">#for SS_CCF score</span>
    <span class="c"># maybe change their name </span></div>
    <span class="k">def</span> <span class="nf">_get_maskArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">densValue</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;ADDED by APP to use with SSCCC score&quot;&quot;&quot;</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_less_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">densValue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">mask_array</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">_get_maskMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maskArray</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;ADDED by APP to use with SSCCC score&quot;&quot;&quot;</span>
        <span class="n">newMap</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">*=</span> <span class="mi">0</span>
        <span class="n">masked_newMAP</span><span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">maskArray</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#.filled() Return a copy of self, with masked values filled with a given value in this case 0</span>
        <span class="n">newMap</span><span class="o">.</span><span class="n">fullMap</span><span class="o">=</span><span class="n">masked_newMAP</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newMap</span>
    
<div class="viewcode-block" id="Map.make_bin_map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.make_bin_map">[docs]</a>    <span class="k">def</span> <span class="nf">make_bin_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return a new Map instance that has been binarised. </span>
<span class="sd">        All voxel with densities above and below the specified cutoff value are assigned a value of 1 and 0 respectively. </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">            *cutoff*</span>
<span class="sd">                cutoff density value</span>

<span class="sd">        Return:</span>
<span class="sd">            new binarised Map instance         </span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">binMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">cutoff</span>
        <span class="n">binMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">newMap</span><span class="o">*-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">binMap</span>
</div>
<div class="viewcode-block" id="Map.make_clash_map"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.make_clash_map">[docs]</a>    <span class="k">def</span> <span class="nf">make_clash_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">apix</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="c">#note this is fine for the structure blured</span>
        <span class="c"># look at note there DAVE NEED TO CTRL</span>
<span class="c">##   that should be used in the blured but must be checked     </span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        NOTE: NEEED TO BE CHECKED.</span>
<span class="sd">        </span>
<span class="sd">        Return an empty Map instance with set Angstrom per pixel sampling (default is 1)</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">/</span><span class="n">apix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">/</span><span class="n">apix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">/</span><span class="n">apix</span><span class="p">))</span>
        <span class="n">clashMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">clashMap</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="n">clashMap</span><span class="o">.</span><span class="n">apix</span> <span class="o">=</span> <span class="n">apix</span>
        <span class="k">return</span> <span class="n">clashMap</span>
</div>
<div class="viewcode-block" id="Map.resample_by_apix"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.resample_by_apix">[docs]</a>    <span class="k">def</span> <span class="nf">resample_by_apix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_apix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Resample the map based on new_apix sampling.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *new_apix*</span>
<span class="sd">                Angstrom per pixel sampling</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">     </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">apix_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">/</span><span class="n">new_apix</span>
        <span class="c">#new_map.apix = new_apix</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">*</span><span class="n">apix_ratio</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">*</span><span class="n">apix_ratio</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">*</span><span class="n">apix_ratio</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">new_map</span><span class="o">.</span><span class="n">apix</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">new_map</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_map</span>
</div>
<div class="viewcode-block" id="Map.resample_by_box_size"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.resample_by_box_size">[docs]</a>    <span class="k">def</span> <span class="nf">resample_by_box_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_box_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Resample the map based on new box size.</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">            *new_box_size*</span>
<span class="sd">                An array containing box dimension in ZYX format</span>
<span class="sd">                </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">new_box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">new_box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">new_box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">new_map</span><span class="o">.</span><span class="n">apix</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">new_box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_map</span>

    <span class="c"># -- Map modifications involving filtering. All still return a new Map instance -- #</span>
</div>
<div class="viewcode-block" id="Map.fourier_transform"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.fourier_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fourier_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Apply Fourier transform on the density map.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">      </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_map</span>
</div>
<div class="viewcode-block" id="Map.fourier_filter"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.fourier_filter">[docs]</a>    <span class="k">def</span> <span class="nf">fourier_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        NOTE: UNDER CONSTRUCTION</span>
<span class="sd">        </span>
<span class="sd">        Return a Map instance of the density map filtered to specific resolution.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">            *resolution*</span>
<span class="sd">                highest frequency value to allow into filtered map</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">               </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier_transform</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="c">#print x,y,z</span>
        <span class="c">#print sum(a.fullMap)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        
        <span class="c">#print sum(a.fullMap)</span>
<span class="c">#===============================================================================</span>
<span class="c">#         &quot;&quot;&quot;a.fullMap[z:a.z_size/2] *= 0</span>
<span class="c">#         a.fullMap[(a.z_size/2):(a.z_size/2)+z] *= 0</span>
<span class="c">#         </span>
<span class="c">#         a.fullMap[:,y:a.y_size/2] *= 0</span>
<span class="c">#         a.fullMap[:,(a.y_size/2):(a.y_size/2)+y] *= 0</span>
<span class="c"># </span>
<span class="c">#         a.fullMap[:,:,x:a.x_size/2] *= 0</span>
<span class="c">#         a.fullMap[:,:,(a.x_size/2):(a.x_size/2)+x] *= 0&quot;&quot;&quot;</span>
<span class="c">#===============================================================================</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">fullMap</span><span class="p">)</span>
        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_map</span>
</div>
<div class="viewcode-block" id="Map.laplace_filtered"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.laplace_filtered">[docs]</a>    <span class="k">def</span> <span class="nf">laplace_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">       Apply Laplacian filter on density maps</span>

<span class="sd">        Return:</span>
<span class="sd">            new Map instance         </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">=</span> <span class="n">laplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_map</span>

    <span class="c"># -- Methods that obtain information from the density map -- #</span>
</div>
<div class="viewcode-block" id="Map.get_vectors"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">get_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Retrieve all non-zero density points in the form of Vector instances.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            An array of 4-tuple (indices of the voxels in x,y,z format and density value)         </span>
<span class="sd">      </span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Map.get_line_between_points"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_line_between_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_line_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return an array of float values representing a line of density values between two points on the map.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">            *point1, point2* </span>
<span class="sd">                Vector instances of the end points co-ordinates of the line.</span>
<span class="sd"> </span>
<span class="sd">        Return:</span>
<span class="sd">            array of floating values         </span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">point1</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">point2</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">noOfPoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v3</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">v3</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">noOfPoints</span><span class="p">))</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    
</div>
<div class="viewcode-block" id="Map.get_com"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_com">[docs]</a>    <span class="k">def</span> <span class="nf">get_com</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Retrieve the centre of mass of the map.</span>

<span class="sd">        Return:</span>
<span class="sd">            Vector instance         </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_x_moment</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">total_y_moment</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">total_z_moment</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">total_mass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">min_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">vectorMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vectors</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vectorMap</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">min_mass</span>
            <span class="n">total_mass</span> <span class="o">+=</span> <span class="n">m</span>
            <span class="n">total_x_moment</span> <span class="o">+=</span> <span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
            <span class="n">total_y_moment</span> <span class="o">+=</span> <span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
            <span class="n">total_z_moment</span> <span class="o">+=</span> <span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="n">x_CoM</span> <span class="o">=</span> <span class="n">total_x_moment</span><span class="o">/</span><span class="n">total_mass</span>
        <span class="n">y_CoM</span> <span class="o">=</span> <span class="n">total_y_moment</span><span class="o">/</span><span class="n">total_mass</span>
        <span class="n">z_CoM</span> <span class="o">=</span> <span class="n">total_z_moment</span><span class="o">/</span><span class="n">total_mass</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">x_CoM</span><span class="p">,</span> <span class="n">y_CoM</span><span class="p">,</span> <span class="n">z_CoM</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.pixel_centre"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.pixel_centre">[docs]</a>    <span class="k">def</span> <span class="nf">pixel_centre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            Vector instance of the centre of the map in pixels.</span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">y_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">z_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">x_centre</span><span class="p">,</span> <span class="n">y_centre</span><span class="p">,</span> <span class="n">z_centre</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.centre"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.centre">[docs]</a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centre of the Map Instance</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            Vector instance of the centre of the map in Angstroms.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">y_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">z_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">x_centre</span><span class="p">,</span> <span class="n">y_centre</span><span class="p">,</span> <span class="n">z_centre</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Map.mean"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            mean density value of map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Map.median"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.median">[docs]</a>    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            median density value of map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.std"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            standard deviation of density values in map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Map.min"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            minimum density value of the map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    </div>
<div class="viewcode-block" id="Map.max"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            maximum density value of the map.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Map.vectorise_point"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.vectorise_point">[docs]</a>    <span class="k">def</span> <span class="nf">vectorise_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return a tuple of the Angstrom co-ordinates and density value of a particular density point in map. </span>
<span class="sd">        Transform the voxel specified by its indices (x,y,z) into a Vector object. The vector defines the position</span>
<span class="sd">        of the voxel with respect to the origin of the map. The magnitude of the vector is in Angstrom units.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            *x, y, z*</span>
<span class="sd">                co-ordinates of the density point to be vectorised.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            Vector instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v_x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v_y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v_z</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c">#density = self.fullMap[z][y][x]</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">v_x</span><span class="p">,</span> <span class="n">v_y</span><span class="p">,</span> <span class="n">v_z</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.get_significant_points"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_significant_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_significant_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Retrieve all points with a density greater than one standard deviation above the mean.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            An array of 4-tuple (indices of the voxels in x,y,z format and density value) </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">boo</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]:</span>
                        <span class="n">sig_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">sig_points</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_get_random_significant_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Return an array of tuple pairs of significant points randomly chosen from &#39;get_significant_points&#39; function.</span>
<span class="sd">        For use with the DCCF and DLSF scoring functions.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *amount*</span>
<span class="sd">                number of significant point pairs to return.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_significant_points</span><span class="p">()</span>
        <span class="n">sig_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
            <span class="n">fst</span> <span class="o">=</span> <span class="n">sig_points</span><span class="p">[</span><span class="n">randrange</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
            <span class="n">snd</span> <span class="o">=</span> <span class="n">sig_points</span><span class="p">[</span><span class="n">randrange</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">fst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fst</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">snd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">snd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">snd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fst</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">snd</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
            <span class="n">sig_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">sig_pairs</span><span class="p">)</span>

<div class="viewcode-block" id="Map.makeKDTree"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.makeKDTree">[docs]</a>    <span class="k">def</span> <span class="nf">makeKDTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minDens</span><span class="p">,</span> <span class="n">maxDens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Returns k-dimensional tree of points in the map with values between those chosen for quick nearest-neighbor lookup.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *minDens*</span>
<span class="sd">                minimum density value to include in k-dimensional tree.</span>
<span class="sd">            *maxDens*</span>
<span class="sd">               maximum density value to include in k-dimensional tree.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            index into a set of k-dimensional points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maplist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">minDens</span><span class="p">,</span> <span class="n">maxDens</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">maplist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.get_pos"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minDens</span><span class="p">,</span> <span class="n">maxDens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify a set of voxels in the map whose density values fall between the specified minimum and maximum values. </span>
<span class="sd">                </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *minDens*</span>
<span class="sd">                 minimum density value to include in array.</span>
<span class="sd">            *maxDens*</span>
<span class="sd">                maximum density value to include in array.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            An array of 3-tuples (indices of the voxels in x,y,z format)</span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDens</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDens</span><span class="p">):</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Map.get_normal_vector"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_normal_vector">[docs]</a>    <span class="k">def</span> <span class="nf">get_normal_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Calculate the normal vector at the point specified. </span>
<span class="sd">        Point calculated using 3SOM algorithm used by Ceulemans H. &amp; Russell R.B. (2004).</span>
<span class="sd">       </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *x_pos, y_pos, z_pos*</span>
<span class="sd">                pixel in map on which to calculate normal vector.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Normal vector at the point specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internal_vecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_pos</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_pos</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z_pos</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">x_pos</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">y_pos</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">z_pos</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">x_pos</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y_pos</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">z_pos</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z_pos</span><span class="p">][</span><span class="n">y_pos</span><span class="p">][</span><span class="n">x_pos</span><span class="p">]:</span>
                            <span class="n">internal_vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_pos</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">y_pos</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="n">z_pos</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span><span class="p">())</span>
                        
        <span class="n">sub_vector</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">internal_vecs</span><span class="p">:</span>
            <span class="n">sub_vector</span> <span class="o">=</span> <span class="n">sub_vector</span><span class="o">+</span><span class="n">v</span>
        <span class="k">return</span> <span class="n">sub_vector</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Map.represent_normal_vectors"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.represent_normal_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">represent_normal_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_threshold</span><span class="p">,</span> <span class="n">max_threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Create a Structure instance representing normal vectors of density points specified.</span>
<span class="sd">                </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *min_threshold, max_threshold*</span>
<span class="sd">                    minimum/maximum values to include in normal vector representation.</span>
<span class="sd">        Return:</span>
<span class="sd">            Structure Instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s">&#39;HETATM    1  C   NOR A   1      23.161  39.732 -25.038  1.00 10.00           C&#39;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">origin</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">box_size</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_threshold</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">fullMap</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_threshold</span><span class="p">:</span>
                        <span class="c">#n_vec = m.get_normal_vector(x,y,z, min_threshold)</span>
                        <span class="n">n_vec</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_normal_vector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
                        <span class="n">n_vec</span> <span class="o">=</span> <span class="n">n_vec</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                        <span class="n">pos_vec</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="c">#a = BioPyAtom(template)</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">BioPyAtom</span><span class="p">()</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">x</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">y</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">z</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">BioPyAtom</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">n_vec</span><span class="o">.</span><span class="n">x</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">n_vec</span><span class="o">.</span><span class="n">y</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">n_vec</span><span class="o">.</span><span class="n">z</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">BioPyAtom</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_vec</span><span class="o">.</span><span class="n">x</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_vec</span><span class="o">.</span><span class="n">y</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_vec</span><span class="o">.</span><span class="n">z</span>
                        <span class="n">atomList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                        <span class="n">atomList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">atomList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">BioPy_Structure</span><span class="p">(</span><span class="n">atomList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomList</span>
        <span class="n">s</span><span class="o">.</span><span class="n">renumber_atoms</span><span class="p">()</span>
        <span class="c">#for x in range(1, len(atomList),2):</span>
        <span class="c">#    s.footer += &#39;CONECT   &#39;+str(x)+&#39;    &#39;+str(x+1)+&#39;\n&#39;</span>
        <span class="k">return</span> <span class="n">s</span>
    
    
<span class="c">#===============================================================================</span>
<span class="c">#    </span>
<span class="c"># #These two values should be calculated for the experimental map, and only</span>
<span class="c"># need to be calculated once, at the beginning. Also note that when</span>
<span class="c"># running the normal_vector_score, the experimental map should be the map1</span>
<span class="c"># parameter (ie, the first one)     </span>
<span class="c">#===============================================================================</span></div>
<div class="viewcode-block" id="Map.get_primary_boundary"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_primary_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">get_primary_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molWeight</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span><span class="n">vol_factor</span><span class="o">=</span><span class="mf">1.21</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Calculates primary boundary density value. Volume of pixels with greater density than output is </span>
<span class="sd">        equivalent to volume given by molecular weight of protein. Uses recursive algorithm. </span>
<span class="sd">               </span>
<span class="sd">        Arguments:</span>
<span class="sd">  </span>
<span class="sd">            *molWeight*</span>
<span class="sd">                molecular weight of protein;</span>
<span class="sd">                use get_prot_mass_from_atoms() if your structure contains HETATOMS else use get_prot_mass_from_res().</span>
<span class="sd">           *low, high*</span>
<span class="sd">               minimum and maximum values between which the boundary will be taken. </span>
<span class="sd">               Initial values should be given by minimum and maximum density values in map.</span>
<span class="sd">            *vol_factor*</span>
<span class="sd">                in cubic Angstroms per Dalton. </span>
<span class="sd">                This is the approximate value for globular proteins used in Chimera (Petterson et al, 2004) from Harpaz 1994.</span>
<span class="sd">                Other recommended volume factor are 1.5 (1.1-1.9) cubic Angstroms per Dalton in EMAN Volume/mass conversions assume a density of 1.35 g/ml (0.81 Da/A3) (~1.23A3/Da)</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            </span>
<span class="sd">            primary boundary density value (float)</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print low,high</span>

        <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">numsum</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">==</span> <span class="n">low</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">10</span><span class="p">:</span>
            <span class="n">all_dens</span> <span class="o">=</span> <span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">all_dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_dens</span><span class="p">)</span>
            <span class="n">all_dens</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">all_dens</span><span class="p">)</span>
            <span class="n">l_ind</span> <span class="o">=</span> <span class="n">all_dens</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">all_dens</span><span class="p">[</span><span class="n">l_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;</span> <span class="mf">0.0000002</span> <span class="ow">or</span> <span class="n">high</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
            <span class="n">est_weight</span> <span class="o">=</span> <span class="nb">long</span><span class="p">(</span><span class="n">numsum</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">low</span><span class="p">)</span><span class="o">*</span><span class="n">new_map</span><span class="o">.</span><span class="n">apix</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="n">vol_factor</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&#39;Exact molecular weight cannot be found. Approx. weight of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">est_weight</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; used instead.&#39;</span> 
            
            <span class="k">return</span> <span class="n">low</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="n">low</span><span class="o">+</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_weight</span> <span class="o">=</span> <span class="nb">long</span><span class="p">(</span><span class="n">numsum</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">thr</span><span class="p">)</span><span class="o">*</span><span class="n">new_map</span><span class="o">.</span><span class="n">apix</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="n">vol_factor</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span>
        <span class="c">#print &quot;this_weight&quot;,this_weight, thr</span>
        <span class="c">#this_weight = long((self.fullMap &gt; thr).sum()*self.apix**3/1210)</span>
        <span class="c">#print thr, this_weight, this_weight.sum()</span>
        <span class="k">if</span> <span class="n">this_weight</span> <span class="o">==</span> <span class="nb">long</span><span class="p">(</span><span class="n">molWeight</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">thr</span>
        <span class="k">elif</span> <span class="n">this_weight</span> <span class="o">&gt;</span> <span class="n">molWeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_map</span><span class="o">.</span><span class="n">get_primary_boundary</span><span class="p">(</span><span class="n">molWeight</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">this_weight</span> <span class="o">&lt;</span> <span class="n">molWeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_map</span><span class="o">.</span><span class="n">get_primary_boundary</span><span class="p">(</span><span class="n">molWeight</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_get_second_boundary_outward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">err_percent</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PRIVATE FUNCTION to calculate the second bound density value. </span>
<span class="sd">        Searching from primary boundary outward.</span>
<span class="sd">        For a given boundary value, it calculates the second bound density value </span>
<span class="sd">        such that a specified number of points whose density values fall between the defined boundaries</span>
<span class="sd">        Uses recursive algorithm. </span>
<span class="sd">        Arguments:  </span>
<span class="sd">           *primary_boundary*</span>
<span class="sd">               primary threshold, normally given by get_primary_boundary method based on protein molecular weight.</span>
<span class="sd">           *noOfPoints*</span>
<span class="sd">                   Number of points to use in the normal vector score - try first with 10% (maybe 5%better) of the number of points in the map ( round((self.map_size())*0.1)</span>
<span class="sd">           *low, high*</span>
<span class="sd">               minimum and maximum values between which the threshold will be taken.</span>
<span class="sd">               low should be equal to the value returned by the get_primary_boundary() method and high is the maximum density values in map.  </span>
<span class="sd">           *err_percent*</span>
<span class="sd">                 default value of 1. Allowed to find a secondary boundary that includes a 1% error.                </span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">             outward secondary boundary density value           </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
          
        <span class="c">#print low, high</span>
        <span class="k">if</span> <span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;</span> <span class="mf">0.0000002</span> <span class="ow">or</span> <span class="n">high</span><span class="o">&lt;</span><span class="n">low</span><span class="p">:</span>
            <span class="n">est_weight</span> <span class="o">=</span>  <span class="n">numsum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">primary_boundary</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&#39;Cannot find value to match number of pixels. Try increasing size of err_percent&#39;</span>
            <span class="k">return</span> <span class="mi">1</span><span class="n">j</span>
        
        <span class="n">thr</span> <span class="o">=</span> <span class="n">low</span><span class="o">+</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_no_of_points</span> <span class="o">=</span> <span class="n">numsum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&lt;</span> <span class="n">thr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">primary_boundary</span><span class="p">))</span>
        <span class="c">#print thr, this_no_of_points</span>
        <span class="k">if</span>  <span class="nb">abs</span><span class="p">(</span><span class="n">this_no_of_points</span> <span class="o">-</span> <span class="n">noOfPoints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">err_percent</span><span class="o">*</span><span class="n">noOfPoints</span><span class="o">/</span><span class="mf">100.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">thr</span>
        <span class="k">elif</span> <span class="n">this_no_of_points</span> <span class="o">&lt;</span> <span class="n">noOfPoints</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_outward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">this_no_of_points</span> <span class="o">&gt;</span> <span class="n">noOfPoints</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_outward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_second_boundary_inward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">err_percent</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        PRIVATE FUNCTION to calculate the second bound density value. </span>
<span class="sd">        Searching from primary boundary inward.</span>
<span class="sd">        For a given boundary value, it calculates the second bound density value </span>
<span class="sd">        such that a specified number of points whose density values fall between the defined boundaries</span>
<span class="sd">        Uses recursive algorithm. </span>
<span class="sd">        Arguments:  </span>
<span class="sd">           *primary_boundary*</span>
<span class="sd">               primary threshold, normally given by get_primary_boundary method based on protein molecular weight.</span>
<span class="sd">           *noOfPoints*</span>
<span class="sd">                   Number of points to use in the normal vector score - try first with 10% (maybe 5%better) of the number of points in the map ( round((self.map_size())*0.1)</span>
<span class="sd">           *low, high*</span>
<span class="sd">               minimum and maximum values between which the threshold will be taken.</span>
<span class="sd">               low should be equal to the value returned by the get_primary_boundary() method and high is the maximum density values in map.  </span>
<span class="sd">           *err_percent*</span>
<span class="sd">                 default value of 1. Allowed to find a secondary boundary that includes a 1% error.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">             outward secondary boundary density value                       </span>
<span class="sd">            &quot;&quot;&quot;</span>
                       
<span class="c">#         print low, high</span>
        <span class="k">if</span> <span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;</span> <span class="mf">0.0000002</span> <span class="ow">or</span> <span class="n">high</span><span class="o">&lt;</span><span class="n">low</span><span class="p">:</span>
            <span class="n">est_weight</span> <span class="o">=</span>  <span class="n">numsum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">primary_boundary</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&#39;Cannot find value to match number of pixels. Try increasing size of err_percent&#39;</span>
            <span class="k">return</span> <span class="mi">1</span><span class="n">j</span>
        
        <span class="n">thr</span> <span class="o">=</span> <span class="n">high</span><span class="o">-</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">this_no_of_points</span> <span class="o">=</span> <span class="n">numsum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&lt;</span> <span class="n">thr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span> <span class="o">&gt;</span> <span class="n">primary_boundary</span><span class="p">))</span>
        <span class="c">#print thr, this_no_of_points, noOfPoints</span>
        <span class="k">if</span>  <span class="nb">abs</span><span class="p">(</span><span class="n">this_no_of_points</span> <span class="o">-</span> <span class="n">noOfPoints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">err_percent</span><span class="o">*</span><span class="n">noOfPoints</span><span class="o">/</span><span class="mf">100.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">thr</span>
        <span class="k">elif</span> <span class="n">this_no_of_points</span> <span class="o">&lt;</span> <span class="n">noOfPoints</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_inward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">this_no_of_points</span> <span class="o">&gt;</span> <span class="n">noOfPoints</span><span class="p">:</span>
            <span class="c">#print &#39;test&#39;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_inward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>

<div class="viewcode-block" id="Map.get_second_boundary"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.get_second_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">get_second_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">err_percent</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the second bound density value. For a given boundary value, </span>
<span class="sd">        it calculates the second bound density value such that a specified number</span>
<span class="sd">        of points whose density values fall between the defined boundaries</span>
<span class="sd">        Uses recursive algorithm. </span>
<span class="sd">         </span>
<span class="sd">        Arguments:  </span>
<span class="sd">           *primary_boundary*</span>
<span class="sd">               primary threshold, normally given by get_primary_boundary method based on protein molecular weight.</span>
<span class="sd">           *noOfPoints*</span>
<span class="sd">                   Number of points to use in the normal vector score - try first with 10% (maybe 5%better) of the number of points in the map ( round((self.map_size())*0.1)</span>
<span class="sd">           *low, high*</span>
<span class="sd">               minimum and maximum values between which the threshold will be taken.</span>
<span class="sd">               low should be equal to the value returned by the get_primary_boundary() method and high is the maximum density values in map.  </span>
<span class="sd">           *err_percent*</span>
<span class="sd">                 default value of 1. Allowed to find a secondary boundary that includes a 1% error.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            secondary boundary density value           </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">bou</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_outward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">err_percent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bou</span> <span class="o">==</span> <span class="mi">1</span><span class="n">j</span><span class="p">:</span>
            <span class="n">bou</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_second_boundary_inward</span><span class="p">(</span><span class="n">primary_boundary</span><span class="p">,</span> <span class="n">noOfPoints</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">err_percent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bou</span>
    
    <span class="c"># DO THIS (SHRINK BOX SIZE TO AROUND SD VALUE)</span></div>
    <span class="k">def</span> <span class="nf">_shrink_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mf">2.</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c"># -- Writing Map instance to files -- #</span>
    
    <span class="k">def</span> <span class="nf">_write_to_xplor_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xplorFileName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;OBSOLETE PRIVATE FUNCTION</span>
<span class="sd">        </span>
<span class="sd">        xplorFileName = name of file to write to. Note that this function does not automatically append a .xplor suffix.&quot;&quot;&quot;</span>
        <span class="n">xplor</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s"> 1 !NTITLE</span><span class="se">\n</span><span class="s">&#39;</span>
        
        <span class="n">xplor</span> <span class="o">+=</span> <span class="s">&#39;REMARKS &#39;</span><span class="o">+</span><span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">xplorFileName</span> <span class="o">+</span> <span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="s">&#39;    written by ME!</span><span class="se">\n</span><span class="s">&#39;</span>
        
        <span class="n">xplor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        
        <span class="n">xplor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">())</span> <span class="o">+</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">())</span>
        
        <span class="n">xplor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="mf">90.0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="mf">90.0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="mf">90.0</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">xplor</span> <span class="o">+=</span> <span class="s">&#39;ZYX</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">flatList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">blockSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">()</span>
        <span class="n">blockNo</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flatList</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">point</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span><span class="o">%</span><span class="mi">6</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point</span><span class="o">%</span><span class="n">blockSize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span> 
                    <span class="n">xplor</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">%</span><span class="n">blockSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xplor</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_grid_line_no</span><span class="p">(</span><span class="n">blockNo</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="n">blockNo</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">point</span><span class="o">%</span><span class="mi">6</span>
            <span class="n">xplor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_point_to_string</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">flatList</span><span class="p">[</span><span class="n">point</span><span class="p">]))</span>
        <span class="n">xplor</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">   -9999&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">file</span><span class="p">(</span><span class="n">xplorFileName</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">xplor</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_to_situs_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">situsFileName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;One day I will do this.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Map.write_to_MRC_file"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.write_to_MRC_file">[docs]</a>    <span class="k">def</span> <span class="nf">write_to_MRC_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mrcfilename</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Write out a MRC file</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            *mrcfilename*</span>
<span class="sd">                name of the output mrc file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_to_binary</span><span class="p">()</span>
        <span class="n">maparray</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullMap</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float32&#39;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mrcfilename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">maparray</span><span class="o">.</span><span class="n">tostring</span><span class="p">())</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Map.update_header"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.update_header">[docs]</a>    <span class="k">def</span> <span class="nf">update_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Update self.header to values currently relevant.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">())</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">())</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">())</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nxstart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">nx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nystart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">ny</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nzstart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">nz</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">mz</span> <span class="o">=</span> <span class="n">nz</span>
        <span class="n">xlen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">ylen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">ny</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">zlen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">nz</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">mapc</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mapr</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">amean</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">ispg</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsymbt</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">xorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mapword</span> <span class="o">=</span> <span class="s">&#39;MAP &#39;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s">&#39;little&#39;</span><span class="p">:</span>
            <span class="n">byteorder</span> <span class="o">=</span> <span class="mh">0x44440000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">byteorder</span> <span class="o">=</span> <span class="mh">0x11110000</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
        <span class="n">nlabels</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">label0</span> <span class="o">=</span> <span class="s">&#39;Created by TEMpy on: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
        <span class="n">otherlabels</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nxstart</span><span class="p">,</span> <span class="n">nystart</span><span class="p">,</span> <span class="n">nzstart</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">ylen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>\
                       <span class="n">mapc</span><span class="p">,</span> <span class="n">mapr</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">amean</span><span class="p">,</span> <span class="n">ispg</span><span class="p">,</span> <span class="n">nsymbt</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">xorigin</span><span class="p">,</span> <span class="n">yorigin</span><span class="p">,</span> <span class="n">zorigin</span><span class="p">,</span> <span class="n">mapword</span><span class="p">,</span> <span class="n">byteorder</span><span class="p">,</span>\
                       <span class="n">rms</span><span class="p">,</span> <span class="n">nlabels</span><span class="p">,</span> <span class="n">label0</span><span class="p">,</span> <span class="n">otherlabels</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="Map.header_to_binary"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.header_to_binary">[docs]</a>    <span class="k">def</span> <span class="nf">header_to_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Returns binary version of map header data. For use in writing out density maps in MRC file format. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">())</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">())</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_size</span><span class="p">())</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nxstart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">nx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nystart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">ny</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nzstart</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="o">-</span><span class="n">nz</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">mz</span> <span class="o">=</span> <span class="n">nz</span>
        <span class="n">xlen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">ylen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">ny</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">zlen</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">nz</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apix</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">mapc</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mapr</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">amean</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">ispg</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsymbt</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
        <span class="n">xorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zorigin</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mapword</span> <span class="o">=</span> <span class="s">&#39;MAP &#39;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s">&#39;little&#39;</span><span class="p">:</span>
            <span class="n">byteorder</span> <span class="o">=</span> <span class="mh">0x44440000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">byteorder</span> <span class="o">=</span> <span class="mh">0x11110000</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
        <span class="n">nlabels</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">label0</span> <span class="o">=</span> <span class="s">&#39;Created by TEMpy on: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
        <span class="n">otherlabels</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>

        <span class="n">fm_string</span> <span class="o">=</span> <span class="s">&#39;=10l6f3l3f2l100s3f4slfl80s720s&#39;</span>
        <span class="n">packed</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fm_string</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nxstart</span><span class="p">,</span> <span class="n">nystart</span><span class="p">,</span> <span class="n">nzstart</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">ylen</span><span class="p">,</span> <span class="n">zlen</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>\
                       <span class="n">mapc</span><span class="p">,</span> <span class="n">mapr</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">amean</span><span class="p">,</span> <span class="n">ispg</span><span class="p">,</span> <span class="n">nsymbt</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">xorigin</span><span class="p">,</span> <span class="n">yorigin</span><span class="p">,</span> <span class="n">zorigin</span><span class="p">,</span> <span class="n">mapword</span><span class="p">,</span> <span class="n">byteorder</span><span class="p">,</span>\
                       <span class="n">rms</span><span class="p">,</span> <span class="n">nlabels</span><span class="p">,</span> <span class="n">label0</span><span class="p">,</span> <span class="n">otherlabels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">packed</span>
</div>
    <span class="k">def</span> <span class="nf">_pad_grid_line_no</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private function to help write data to map files.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">spaces</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">spaces</span> <span class="o">+</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span>
    
    <span class="k">def</span> <span class="nf">_convert_point_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private function to help write data to map files.&quot;&quot;&quot;</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.0001</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">point</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="s">&#39;+&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">10.0</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">/=</span> <span class="mf">10.0</span>
            <span class="n">exp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pointString</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointString</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pointString</span><span class="p">),</span> <span class="mi">7</span><span class="p">):</span>
                <span class="n">pointString</span> <span class="o">+=</span> <span class="s">&#39;0&#39;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointString</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">pointString</span> <span class="o">=</span> <span class="n">pointString</span><span class="p">[:</span><span class="mi">7</span><span class="p">]</span>
        <span class="n">pointString</span> <span class="o">+=</span> <span class="s">&#39;E&#39;</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">+</span> <span class="s">&#39;0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39; &#39;</span><span class="o">+</span><span class="n">pointString</span>

    <span class="k">def</span> <span class="nf">_get_component_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">struct</span><span class="p">,</span> <span class="n">apix</span><span class="p">,</span> <span class="n">blurrer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private function for check on Map instance.&quot;&quot;&quot;</span>
    	<span class="n">mapCoM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_com</span><span class="p">()</span>
    	<span class="n">ssplit</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">split_into_chains</span><span class="p">()</span>
    	<span class="n">temp_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_clash_map</span><span class="p">(</span><span class="n">apix</span><span class="p">)</span>

    	<span class="n">overlay_maplist</span> <span class="o">=</span> <span class="p">[]</span>
    	<span class="n">cvol</span> <span class="o">=</span> <span class="p">[]</span>
    	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ssplit</span><span class="p">:</span>
        	<span class="n">tx</span> <span class="o">=</span> <span class="n">mapCoM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">CoM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        	<span class="n">ty</span> <span class="o">=</span> <span class="n">mapCoM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">CoM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        	<span class="n">tz</span> <span class="o">=</span> <span class="n">mapCoM</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">CoM</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        	<span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="n">ty</span><span class="p">,</span><span class="n">tz</span><span class="p">)</span>
        	<span class="n">overlay_maplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blurrer</span><span class="o">.</span><span class="n">make_atom_overlay_map1</span><span class="p">(</span><span class="n">temp_grid</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    	<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">overlay_maplist</span><span class="p">:</span>
		<span class="n">cvol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">fullMap</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">apix</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
    	<span class="k">return</span> <span class="n">cvol</span>
 
 <span class="c">#added by PAP</span>
<div class="viewcode-block" id="Map.map_rotate_by_axis_angle"><a class="viewcode-back" href="../EMMap.html#EMMap.Map.map_rotate_by_axis_angle">[docs]</a>    <span class="k">def</span> <span class="nf">map_rotate_by_axis_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">CoM</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Map instance rotated around its centre.</span>
<span class="sd">                        </span>
<span class="sd">        Arguments:  </span>
<span class="sd">            *angle*</span>
<span class="sd">                angle (in radians if rad == True, else in degrees) to rotate map.</span>
<span class="sd">            *x,y,z*</span>
<span class="sd">                axis to rotate about, ie. x,y,z =  0,0,1 rotates the Map round the xy-plane.</span>
<span class="sd">            *CoM*</span>
<span class="sd">                centre of mass around which map will be rotated. </span>
<span class="sd">                </span>
<span class="sd">        Return:</span>
<span class="sd">            Rotated new Map instance         </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">axis_angle_to_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
        <span class="c">#print Vector(x,y,z).unit()</span>

        <span class="c"># Calculate translation needed to rotate around CoM</span>
        <span class="n">newCoM</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">CoM</span><span class="o">-</span><span class="n">newCoM</span>

        <span class="c"># Apply transform</span>
        <span class="n">newMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newMap</span>

<span class="c">#===============================================================================</span>
<span class="c"># #added by PAP</span>
<span class="c">#     def _map_randomise_position(self, i, max_trans, max_rot, CoM, v_grain=30, rad=False, verbose=False):</span>
<span class="c">#         &quot;&quot;&quot;</span>
<span class="c">#         WE </span>
<span class="c">#         Randomise the position of the map instance and return the modified map.</span>
<span class="c">#                </span>
<span class="c">#         Arguments:  </span>
<span class="c"># </span>
<span class="c">#             *ARUN need to add it*</span>
<span class="c">#             </span>
<span class="c">#         </span>
<span class="c">#         &quot;&quot;&quot;</span>
<span class="c">#         t_v = random_vector(-v_grain, v_grain).unit()</span>
<span class="c">#         r_v = random_vector(-v_grain, v_grain).unit()</span>
<span class="c">#         j = 1</span>
<span class="c">#         if max_trans &lt;= 0:</span>
<span class="c">#             t_dist = 0</span>
<span class="c">#         else:</span>
<span class="c">#             t_dist = randrange(1,max_trans)</span>
<span class="c"># </span>
<span class="c">#         if max_rot &lt;= 0:</span>
<span class="c">#             r_ang = 0</span>
<span class="c">#         else:</span>
<span class="c">#             r_ang = randrange(1,max_rot)</span>
<span class="c"># </span>
<span class="c">#         t_v = t_v.times(t_dist)</span>
<span class="c">#         #self.rotate_by_axis_angle(r_v.x, r_v.y, r_v.z, r_ang, t_v.x, t_v.y, t_v.z, rad=rad)</span>
<span class="c">#         rotmap = self.rotate_by_axis_angle(r_v.x, r_v.y, r_v.z, r_ang, CoM, rad=rad)</span>
<span class="c">#         if verbose:</span>
<span class="c">#             print &#39;%6d %7.3f %7.3f %7.3f  %5.2f  %5.2f&#39; % (i,r_v.x,r_v.y,r_v.z,t_dist,r_ang)</span>
<span class="c">#         return rotmap.translate(t_v.x, t_v.y, t_v.z),r_v.x,r_v.y,r_v.z,t_dist,r_ang</span>
<span class="c">#===============================================================================</span>

 </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">1. Installation on Linux &amp; Mac OSX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">2. How to use TEMPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StructureParser.html">3. Parser for Structure Instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ProtRep_Biopy.html">4. Class to define and manipulate protein structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MapParser.html">5. Parser for Density Map Instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StructureBlurrer.html">6. Density Map Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EMMap.html">7. Density Map Instance Informations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RigidBodyParser.html">8. Read Rigid Body Files in Flex-EM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransformParser.html">9. Parser for Transformation Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EnsembleGeneration.html">10. Generation an Ensemble of Structure Instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ScoringFunctions.html">11. Scoring Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Cluster.html">12. Clustering multiple fits in a cryoEM map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ShowPlot.html">13. Plotting and Output Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Vector.html">14. Core Modules : Vector</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>

          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013-2014, Birkbeck College, University of London.
      Last updated on Jun 10, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>